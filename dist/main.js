/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// @flow\n// @format\n//\n// The core functionality for l-systems is like this.\nfunction rewrite(state, rules) {\n  let result = \"\";\n  for (let i = 0; i < state.length; i++) {\n    const current = state[i];\n    const replacements = rules[current] || [];\n    if (replacements.length == 0) {\n      result += current;\n    } else if (replacements.length == 1) {\n      result += replacements[0];\n    } else {\n      throw new Error(\"Unsupported as of yet.\");\n    }\n  }\n  return result;\n}\n\nfunction move(x, y, heading, length) {\n  const dx = length * Math.cos(heading);\n  const dy = length * Math.sin(heading);\n  return [x + dx, y + dy];\n}\n\nclass MeasureContext {\n  /*::\n  min_x: number;\n  min_y: number;\n  max_x: number;\n  max_y: number;\n  */\n\n  constructor() {\n    this.min_x = 0;\n    this.max_x = 0;\n    this.min_y = 0;\n    this.max_y = 0;\n  }\n  beginPath() {}\n  stroke() {}\n  moveTo(x, y) {\n    if (this.min_x === undefined || x < this.min_x) {\n      this.min_x = x;\n    }\n    if (this.max_x === undefined || x > this.max_x) {\n      this.max_x = x;\n    }\n    if (this.min_y === undefined || y < this.min_y) {\n      this.min_y = y;\n    }\n    if (this.max_y === undefined || y > this.max_y) {\n      this.max_y = y;\n    }\n  }\n  lineTo(x, y) {\n    this.moveTo(x, y);\n  }\n}\n\nfunction render(state, context, config) {\n  let { x, y, heading, step_length, angle_delta } = config;\n  const state_stack = [];\n\n  context.beginPath();\n  context.moveTo(x, y);\n\n  for (let i = 0; i < state.length; i++) {\n    const current = state[i];\n    if (current == \"F\") {\n      // Move forward by straight_length\n      const [new_x, new_y] = move(x, y, heading, step_length);\n      context.lineTo(new_x, new_y);\n      x = new_x;\n      y = new_y;\n    } else if (current == \"f\") {\n      const [new_x, new_y] = move(x, y, heading, step_length);\n      context.moveTo(new_x, new_y);\n      x = new_x;\n      y = new_y;\n    } else if (current == \"+\") {\n      heading += angle_delta;\n    } else if (current == \"-\") {\n      heading -= angle_delta;\n    } else if (current == \"[\") {\n      state_stack.push([x, y, heading]);\n    } else if (current == \"]\") {\n      [x, y, heading] = state_stack.pop();\n      context.moveTo(x, y);\n    }\n  }\n\n  context.stroke();\n}\n\nfunction toRadians(degrees) {\n  return degrees * (Math.PI / 180.0);\n}\n\n// Definition here:\nconst initial = \"X\";\nconst angle = toRadians(22.5);\nconst rules = {\n  X: [\"F-[[X]+X]+F[+FX]-X\"],\n  F: [\"FF\"],\n};\n\n// HTML mechanics, WebGL bullshit.\nconst vsSource = `\nattribute vec4 aVertexPosition;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main() {\n  gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;\n}\n`;\nconst fsSource = `\n  void main() {\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n  }\n`;\n\nfunction initShaderProgram(gl, vsSource, fsSource) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\n\n  const shaderProgram = gl.createProgram();\n  if (shaderProgram == null) {\n    throw new Error(\"Unable to create shader program\");\n  }\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    console.error(\n      \"Unable to initialize the shader program: \" +\n        (gl.getProgramInfoLog(shaderProgram) || \"\")\n    );\n    throw new Error(\"Failed to init shader program\");\n  }\n\n  return shaderProgram;\n}\n\nfunction loadShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\n      \"An error occurred compiling the shaders: \" +\n        (gl.getShaderInfoLog(shader) || \"\")\n    );\n    gl.deleteShader(shader);\n    throw new Error(\"Failed to load shader\");\n  }\n\n  return shader;\n}\n\nfunction initBuffers(gl) {\n  const positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n  const positions = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0];\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n  return {\n    position: positionBuffer,\n  };\n}\n\nfunction setup(gl) {\n  gl.clearColor(0, 0, 0, 1);\n  gl.clearDepth(1.0);\n  gl.enable(gl.DEPTH_TEST);\n  gl.depthFunc(gl.LEQUAL);\n\n  const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n  const programInfo = {\n    program: shaderProgram,\n    attribLocations: {\n      vertexPosition: gl.getAttribLocation(shaderProgram, \"aVertexPosition\"),\n    },\n    uniformLocations: {\n      projectionMatrix: gl.getUniformLocation(\n        shaderProgram,\n        \"uProjectionMatrix\"\n      ),\n      modelViewMatrix: gl.getUniformLocation(shaderProgram, \"uModelViewMatrix\"),\n    },\n  };\n  return programInfo;\n}\n\nconst garden = document.getElementById(\"garden\");\nif (!(garden && garden instanceof HTMLCanvasElement)) {\n  throw Error(\"Cannot find garden.\");\n}\nconst gardenContext = garden.getContext(\"webgl\");\nif (gardenContext == null) {\n  throw Error(\"Cannot get GL context.\");\n}\nconst programInfo = setup(gardenContext);\nconst buffers = initBuffers(gardenContext);\n\nconst render_config = {\n  x: 0,\n  y: 0,\n  heading: Math.PI * 1.5,\n  step_length: 10,\n  step_factor: 1,\n  angle_delta: angle,\n};\n\nlet state = initial;\nfunction draw(gl) {\n  // Step 1: Measure the boundaries of the plant.\n  const measure_context = new MeasureContext();\n  render(state, measure_context, render_config);\n  const render_width = measure_context.max_x - measure_context.min_x;\n  const render_height = measure_context.max_y - measure_context.min_y;\n\n  // Step 2: Draw the plant.\n\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  // gardenContext.clearRect(0, 0, garden.width, garden.height);\n  // gardenContext.save();\n  // gardenContext.scale(\n  //   garden.width / render_width,\n  //   garden.height / render_height\n  // );\n  // gardenContext.translate(-measure_context.min_x, -measure_context.min_y);\n  // render(state, gardenContext, render_config);\n  // gardenContext.restore();\n}\n\nfunction step() {\n  state = rewrite(state, rules);\n  render_config.step_length /= render_config.step_factor;\n  draw(gardenContext);\n}\n\nconst stepButton = document.getElementById(\"step\");\nif (!stepButton) {\n  throw Error(\"Cannot find step button.\");\n}\nstepButton.addEventListener(\"click\", step);\ndraw(gardenContext);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLy8gQGZvcm1hdFxuLy9cbi8vIFRoZSBjb3JlIGZ1bmN0aW9uYWxpdHkgZm9yIGwtc3lzdGVtcyBpcyBsaWtlIHRoaXMuXG5mdW5jdGlvbiByZXdyaXRlKHN0YXRlLCBydWxlcykge1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBzdGF0ZVtpXTtcbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSBydWxlc1tjdXJyZW50XSB8fCBbXTtcbiAgICBpZiAocmVwbGFjZW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICByZXN1bHQgKz0gY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgcmVzdWx0ICs9IHJlcGxhY2VtZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYXMgb2YgeWV0LlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW92ZSh4LCB5LCBoZWFkaW5nLCBsZW5ndGgpIHtcbiAgY29uc3QgZHggPSBsZW5ndGggKiBNYXRoLmNvcyhoZWFkaW5nKTtcbiAgY29uc3QgZHkgPSBsZW5ndGggKiBNYXRoLnNpbihoZWFkaW5nKTtcbiAgcmV0dXJuIFt4ICsgZHgsIHkgKyBkeV07XG59XG5cbmNsYXNzIE1lYXN1cmVDb250ZXh0IHtcbiAgLyo6OlxuICBtaW5feDogbnVtYmVyO1xuICBtaW5feTogbnVtYmVyO1xuICBtYXhfeDogbnVtYmVyO1xuICBtYXhfeTogbnVtYmVyO1xuICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWluX3ggPSAwO1xuICAgIHRoaXMubWF4X3ggPSAwO1xuICAgIHRoaXMubWluX3kgPSAwO1xuICAgIHRoaXMubWF4X3kgPSAwO1xuICB9XG4gIGJlZ2luUGF0aCgpIHt9XG4gIHN0cm9rZSgpIHt9XG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgaWYgKHRoaXMubWluX3ggPT09IHVuZGVmaW5lZCB8fCB4IDwgdGhpcy5taW5feCkge1xuICAgICAgdGhpcy5taW5feCA9IHg7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heF94ID09PSB1bmRlZmluZWQgfHwgeCA+IHRoaXMubWF4X3gpIHtcbiAgICAgIHRoaXMubWF4X3ggPSB4O1xuICAgIH1cbiAgICBpZiAodGhpcy5taW5feSA9PT0gdW5kZWZpbmVkIHx8IHkgPCB0aGlzLm1pbl95KSB7XG4gICAgICB0aGlzLm1pbl95ID0geTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4X3kgPT09IHVuZGVmaW5lZCB8fCB5ID4gdGhpcy5tYXhfeSkge1xuICAgICAgdGhpcy5tYXhfeSA9IHk7XG4gICAgfVxuICB9XG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyKHN0YXRlLCBjb250ZXh0LCBjb25maWcpIHtcbiAgbGV0IHsgeCwgeSwgaGVhZGluZywgc3RlcF9sZW5ndGgsIGFuZ2xlX2RlbHRhIH0gPSBjb25maWc7XG4gIGNvbnN0IHN0YXRlX3N0YWNrID0gW107XG5cbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBzdGF0ZVtpXTtcbiAgICBpZiAoY3VycmVudCA9PSBcIkZcIikge1xuICAgICAgLy8gTW92ZSBmb3J3YXJkIGJ5IHN0cmFpZ2h0X2xlbmd0aFxuICAgICAgY29uc3QgW25ld194LCBuZXdfeV0gPSBtb3ZlKHgsIHksIGhlYWRpbmcsIHN0ZXBfbGVuZ3RoKTtcbiAgICAgIGNvbnRleHQubGluZVRvKG5ld194LCBuZXdfeSk7XG4gICAgICB4ID0gbmV3X3g7XG4gICAgICB5ID0gbmV3X3k7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50ID09IFwiZlwiKSB7XG4gICAgICBjb25zdCBbbmV3X3gsIG5ld195XSA9IG1vdmUoeCwgeSwgaGVhZGluZywgc3RlcF9sZW5ndGgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8obmV3X3gsIG5ld195KTtcbiAgICAgIHggPSBuZXdfeDtcbiAgICAgIHkgPSBuZXdfeTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT0gXCIrXCIpIHtcbiAgICAgIGhlYWRpbmcgKz0gYW5nbGVfZGVsdGE7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50ID09IFwiLVwiKSB7XG4gICAgICBoZWFkaW5nIC09IGFuZ2xlX2RlbHRhO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCA9PSBcIltcIikge1xuICAgICAgc3RhdGVfc3RhY2sucHVzaChbeCwgeSwgaGVhZGluZ10pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudCA9PSBcIl1cIikge1xuICAgICAgW3gsIHksIGhlYWRpbmddID0gc3RhdGVfc3RhY2sucG9wKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cblxuICBjb250ZXh0LnN0cm9rZSgpO1xufVxuXG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwLjApO1xufVxuXG4vLyBEZWZpbml0aW9uIGhlcmU6XG5jb25zdCBpbml0aWFsID0gXCJYXCI7XG5jb25zdCBhbmdsZSA9IHRvUmFkaWFucygyMi41KTtcbmNvbnN0IHJ1bGVzID0ge1xuICBYOiBbXCJGLVtbWF0rWF0rRlsrRlhdLVhcIl0sXG4gIEY6IFtcIkZGXCJdLFxufTtcblxuLy8gSFRNTCBtZWNoYW5pY3MsIFdlYkdMIGJ1bGxzaGl0LlxuY29uc3QgdnNTb3VyY2UgPSBgXG5hdHRyaWJ1dGUgdmVjNCBhVmVydGV4UG9zaXRpb247XG5cbnVuaWZvcm0gbWF0NCB1TW9kZWxWaWV3TWF0cml4O1xudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuXG52b2lkIG1haW4oKSB7XG4gIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1TW9kZWxWaWV3TWF0cml4ICogYVZlcnRleFBvc2l0aW9uO1xufVxuYDtcbmNvbnN0IGZzU291cmNlID0gYFxuICB2b2lkIG1haW4oKSB7XG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xuICB9XG5gO1xuXG5mdW5jdGlvbiBpbml0U2hhZGVyUHJvZ3JhbShnbCwgdnNTb3VyY2UsIGZzU291cmNlKSB7XG4gIGNvbnN0IHZlcnRleFNoYWRlciA9IGxvYWRTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZzU291cmNlKTtcbiAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBsb2FkU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZzU291cmNlKTtcblxuICBjb25zdCBzaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBpZiAoc2hhZGVyUHJvZ3JhbSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBzaGFkZXIgcHJvZ3JhbVwiKTtcbiAgfVxuICBnbC5hdHRhY2hTaGFkZXIoc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wubGlua1Byb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlclByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlVuYWJsZSB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbTogXCIgK1xuICAgICAgICAoZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coc2hhZGVyUHJvZ3JhbSkgfHwgXCJcIilcbiAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBpbml0IHNoYWRlciBwcm9ncmFtXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNoYWRlclByb2dyYW07XG59XG5cbmZ1bmN0aW9uIGxvYWRTaGFkZXIoZ2wsIHR5cGUsIHNvdXJjZSkge1xuICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCBjb21waWxpbmcgdGhlIHNoYWRlcnM6IFwiICtcbiAgICAgICAgKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSB8fCBcIlwiKVxuICAgICk7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc2hhZGVyXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNoYWRlcjtcbn1cblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoZ2wpIHtcbiAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcblxuICBjb25zdCBwb3NpdGlvbnMgPSBbMS4wLCAxLjAsIC0xLjAsIDEuMCwgMS4wLCAtMS4wLCAtMS4wLCAtMS4wXTtcbiAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uQnVmZmVyLFxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXR1cChnbCkge1xuICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xuICBnbC5jbGVhckRlcHRoKDEuMCk7XG4gIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XG5cbiAgY29uc3Qgc2hhZGVyUHJvZ3JhbSA9IGluaXRTaGFkZXJQcm9ncmFtKGdsLCB2c1NvdXJjZSwgZnNTb3VyY2UpO1xuICBjb25zdCBwcm9ncmFtSW5mbyA9IHtcbiAgICBwcm9ncmFtOiBzaGFkZXJQcm9ncmFtLFxuICAgIGF0dHJpYkxvY2F0aW9uczoge1xuICAgICAgdmVydGV4UG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwiYVZlcnRleFBvc2l0aW9uXCIpLFxuICAgIH0sXG4gICAgdW5pZm9ybUxvY2F0aW9uczoge1xuICAgICAgcHJvamVjdGlvbk1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKFxuICAgICAgICBzaGFkZXJQcm9ncmFtLFxuICAgICAgICBcInVQcm9qZWN0aW9uTWF0cml4XCJcbiAgICAgICksXG4gICAgICBtb2RlbFZpZXdNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcInVNb2RlbFZpZXdNYXRyaXhcIiksXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHByb2dyYW1JbmZvO1xufVxuXG5jb25zdCBnYXJkZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhcmRlblwiKTtcbmlmICghKGdhcmRlbiAmJiBnYXJkZW4gaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcbiAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgZmluZCBnYXJkZW4uXCIpO1xufVxuY29uc3QgZ2FyZGVuQ29udGV4dCA9IGdhcmRlbi5nZXRDb250ZXh0KFwid2ViZ2xcIik7XG5pZiAoZ2FyZGVuQ29udGV4dCA9PSBudWxsKSB7XG4gIHRocm93IEVycm9yKFwiQ2Fubm90IGdldCBHTCBjb250ZXh0LlwiKTtcbn1cbmNvbnN0IHByb2dyYW1JbmZvID0gc2V0dXAoZ2FyZGVuQ29udGV4dCk7XG5jb25zdCBidWZmZXJzID0gaW5pdEJ1ZmZlcnMoZ2FyZGVuQ29udGV4dCk7XG5cbmNvbnN0IHJlbmRlcl9jb25maWcgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIGhlYWRpbmc6IE1hdGguUEkgKiAxLjUsXG4gIHN0ZXBfbGVuZ3RoOiAxMCxcbiAgc3RlcF9mYWN0b3I6IDEsXG4gIGFuZ2xlX2RlbHRhOiBhbmdsZSxcbn07XG5cbmxldCBzdGF0ZSA9IGluaXRpYWw7XG5mdW5jdGlvbiBkcmF3KGdsKSB7XG4gIC8vIFN0ZXAgMTogTWVhc3VyZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcGxhbnQuXG4gIGNvbnN0IG1lYXN1cmVfY29udGV4dCA9IG5ldyBNZWFzdXJlQ29udGV4dCgpO1xuICByZW5kZXIoc3RhdGUsIG1lYXN1cmVfY29udGV4dCwgcmVuZGVyX2NvbmZpZyk7XG4gIGNvbnN0IHJlbmRlcl93aWR0aCA9IG1lYXN1cmVfY29udGV4dC5tYXhfeCAtIG1lYXN1cmVfY29udGV4dC5taW5feDtcbiAgY29uc3QgcmVuZGVyX2hlaWdodCA9IG1lYXN1cmVfY29udGV4dC5tYXhfeSAtIG1lYXN1cmVfY29udGV4dC5taW5feTtcblxuICAvLyBTdGVwIDI6IERyYXcgdGhlIHBsYW50LlxuXG4gIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAvLyBnYXJkZW5Db250ZXh0LmNsZWFyUmVjdCgwLCAwLCBnYXJkZW4ud2lkdGgsIGdhcmRlbi5oZWlnaHQpO1xuICAvLyBnYXJkZW5Db250ZXh0LnNhdmUoKTtcbiAgLy8gZ2FyZGVuQ29udGV4dC5zY2FsZShcbiAgLy8gICBnYXJkZW4ud2lkdGggLyByZW5kZXJfd2lkdGgsXG4gIC8vICAgZ2FyZGVuLmhlaWdodCAvIHJlbmRlcl9oZWlnaHRcbiAgLy8gKTtcbiAgLy8gZ2FyZGVuQ29udGV4dC50cmFuc2xhdGUoLW1lYXN1cmVfY29udGV4dC5taW5feCwgLW1lYXN1cmVfY29udGV4dC5taW5feSk7XG4gIC8vIHJlbmRlcihzdGF0ZSwgZ2FyZGVuQ29udGV4dCwgcmVuZGVyX2NvbmZpZyk7XG4gIC8vIGdhcmRlbkNvbnRleHQucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBzdGVwKCkge1xuICBzdGF0ZSA9IHJld3JpdGUoc3RhdGUsIHJ1bGVzKTtcbiAgcmVuZGVyX2NvbmZpZy5zdGVwX2xlbmd0aCAvPSByZW5kZXJfY29uZmlnLnN0ZXBfZmFjdG9yO1xuICBkcmF3KGdhcmRlbkNvbnRleHQpO1xufVxuXG5jb25zdCBzdGVwQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGVwXCIpO1xuaWYgKCFzdGVwQnV0dG9uKSB7XG4gIHRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgc3RlcCBidXR0b24uXCIpO1xufVxuc3RlcEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgc3RlcCk7XG5kcmF3KGdhcmRlbkNvbnRleHQpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });